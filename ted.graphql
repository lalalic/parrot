directive @composedGraph(version: Int!) on SCHEMA

directive @graph(name: String!, url: String!) on SCHEMA

directive @owner(graph: String!) on OBJECT

directive @key(fields: String!, graph: String!) on OBJECT

directive @resolve(graph: String!) on FIELD_DEFINITION

directive @provides(fields: String!) on FIELD_DEFINITION

directive @requires(fields: String!) on FIELD_DEFINITION

type AcmeLanguage {
  # The name of the language as written and reffered to by its community.
  endonym: String

  # The name of the language as written in English.
  englishName: String

  # A string identifying the language assigned by the Internet Assigned Numbers Authority.
  ianaSubtag: String

  # A short code used to identify the language by TED.
  internalLanguageCode: String

  # A boolean indicating whether the language is written right to left.
  isRtl: Boolean

  # A two letter lowercase abbreviation assigned by ISO.
  iso6391: String

  # A three letter lowercase abbreviation assigned by ISO.
  iso6393: String
}

# The connection type for AcmeLanguage.
type AcmeLanguageConnection {
  # A list of edges.
  edges: [AcmeLanguageEdge]

  # A list of nodes.
  nodes: [AcmeLanguage]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type AcmeLanguageEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: AcmeLanguage
}

# A string of JSON, that can be parsed, and passed to the TED video player.
scalar AcmePlayerData

type AcmeSpeaker {
  # A short bit of plaintext, telling who said "what others say"
  cite: String

  # A short (max 500) plain-text description of the speaker. About half are blank.
  description: String

  # Speaker's first name. By convention this will be blank for single-name speakers like 'Bono'
  firstname: String
  id: ID

  # Whether the speaker is currently live to the world.
  isLive: Boolean

  # Speaker's last name. If the speaker has only one name (like 'Bono') that name will be in this field.
  lastname: String

  # Short text for the anchor tag
  linkName1: String

  # Short text for the anchor tag
  linkName2: String

  # Usually a FQDN, but some lack a protocol. Often blank.
  linkUrl1: String

  # Same as link_url_1, but more often blank. Some mailto: links! Usually a twitter URL.
  linkUrl2: String

  # A speaker's middlename, though it's almost always just an initial. Usually blank.
  middlename: String

  # Link to a photo of the speaker via TED's CDN.
  photoUrl: String

  # A short human-readable identifier for this speaker. Suitable for building URLs.
  slug: String

  # The title the speaker holds, often indiciating their affiliation.
  title: String

  # A short blurb with perspective on the speaker.
  whatOthersSay: String

  # Usually a short bit of HTML (a few <em> tags) but some are over 2,000 characters. May be blank in some cases.
  whoTheyAre: String

  # A pile of HTML. Longest is ~5,000 characters. Usually blank.
  whyListen: String
}

# The connection type for AcmeSpeaker.
type AcmeSpeakerConnection {
  # A list of edges.
  edges: [AcmeSpeakerEdge]

  # A list of nodes.
  nodes: [AcmeSpeaker]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type AcmeSpeakerEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: AcmeSpeaker
}

# Autogenerated return type of AddPaymentMethod
type AddPaymentMethodPayload {
  status: String!
}

type AspectRatio {
  id: ID

  # width:length or a plain language title for the aspect ratio
  name: String
}

# Autogenerated return type of CancelMembershipEventRegistration
type CancelMembershipEventRegistrationPayload {
  errors: [String!]
  membershipEvent: MembershipEvent
}

# Autogenerated return type of CancelStripeSupporterSubscription
type CancelStripeSupporterSubscriptionPayload {
  success: Boolean
}

type Card {
  brand: String!
  expMonth: String!
  expYear: String!
  last4: String!
}

# A list of talkstar channels
enum ChannelOptions {
  # All talkstar talks
  ALL

  # Talkstar talks published to the homepage
  FEATURED
}

# Autogenerated return type of CreatePaymentIntentClientSecret
type CreatePaymentIntentClientSecretPayload {
  clientSecret: String!
  paymentMethodId: String!
  status: String!
}

# Autogenerated return type of CreateStripeSupporterSubscription
type CreateStripeSupporterSubscriptionPayload {
  redemptionToken: String
  success: Boolean!
}

type Cue {
  text: String!
  time: Int!
}

# A list of playlist curator types
enum CuratorOptions {
  # Curated by a User
  COMMUNITY

  # Curated by TED
  EDITORIAL

  # Curated by a guest/celebrity
  GUEST
}

type CustomContentDetails {
  # When we fake the partner in as a speaker, this is their avatar.
  partnerAvatarUrl: URL

  # When we fake the partner in as a speaker, this is their 'bio.'
  partnerDescription: String

  # When we fake the partner in as a speaker, this is their 'name.'
  partnerName: String
}

type EmailStatus {
  id: ID!
  halted: Boolean!
  haltedSince: String
  haltedBy: String
}

enum EmailStatusEnum {
  ON
  OFF
}

type Endorsement {
  id: ID!
  user: User!
  text: String
  featured: Boolean!
  upvotes: EndorsementUsersConnection!
  upvotedByViewer: Boolean!
  video: Video!
  motivators: [ExploreMotivator!]!
}

type EndorsementsConnection {
  count: Int!
  edges: [EndorsementsEdge]
}

type EndorsementsEdge {
  node: Endorsement!
  cursor: String!
}

input EndorsementSubmitInput {
  videoId: ID!
  text: String
  motivators: [ID!]
}

type EndorsementSubmitResponse {
  endorsement: Endorsement
}

type EndorsementUpvoteResponse {
  endorsement: Endorsement
}

type EndorsementUsersConnection {
  count: Int!
  edges: [EndorsementUsersEdge!]!
}

type EndorsementUsersEdge {
  cursor: ID!
  node: User!
}

# Some extra schmutz that needs to go on the page in some cases.
type EventBadge {
  # Why a URL, and not an Image? Because don't worry about the sizes, just put it on the page.
  imageUrl: URL!

  # If this is present, the image (see imageUrl) should be a hyperlink to this
  # URL. (...Why didn't we make this a URL field?) We're not sold on this name, btw.
  website: String
}

type ExploreMotivator {
  id: ID!
  label: String!
}

type ExploreStatus {
  email: EmailStatus!
}

# Statuses a TalkExtra can have
enum ExtraStatus {
  # it's approved
  APPROVED

  # it's a draft
  DRAFT

  # it's expired
  EXPIRED
  READY_FOR_COPY_EDIT
}

type Favorite {
  favoriteable: Favoriteable
  id: ID!
}

type Favoriteable {
  id: ID!
  type: String!
}

input FavoriteableFilter {
  id: ID!
  type: String!
}

# The connection type for Favorite.
type FavoriteConnection {
  # A list of edges.
  edges: [FavoriteEdge]

  # A list of nodes.
  nodes: [Favorite]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type FavoriteEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Favorite
}

input FavoriteInput {
  id: ID!
  type: String!
}

input FavoritesFilter {
  favoriteables: [FavoriteableFilter!]
  type: String
}

type Follow {
  id: ID!
  subject: FollowSubject
}

# The connection type for Follow.
type FollowConnection {
  # A list of edges.
  edges: [FollowEdge]

  # A list of nodes.
  nodes: [Follow]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

# An edge in a connection.
type FollowEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Follow
}

input FollowsFilter {
  subjects: [SubjectFilter!]
  type: String
}

type FollowSubject {
  id: ID!
  type: String!
}

input FollowSubjectInput {
  id: ID!
  type: String!
}

# A Footnote (citation, correction) from TalkExtras
type Footnote {
  # Probably only on citations, not corrections
  annotation: String
  author: String

  # article, book, note, or video; probably only on citations, not corrections
  category: String

  # Some date-ish text. Eg: "July 2006", but also eg: "2003", or a URL, or "TK". Don't parse it. Just display it.
  date: String
  isPdf: Boolean
  linkUrl: URL
  published: Boolean!

  # The source for the footnote (citation): a journal, report, etc
  source: String
  status: ExtraStatus!
  text: String

  # The minutes:seconds into the video for this footnote. Eg: 01:23
  timecode: String
  title: String
}

enum GeneratedAvatar {
  RASTER
  SVG
}

type InterestRecordResponse {
  interest: UserInterest
}

# An ISO 8601-encoded date
scalar ISO8601Date

# An ISO 8601-encoded datetime
scalar ISO8601DateTime

type Language {
  endonym: String
  englishName: String!
  id: ID!
  internalLanguageCode: String!
  rtl: Boolean!
}

# A LearnModule from talk extras. Aka a Learn *more* module, or 'More Resources.'
type LearnModule {
  author: String
  blurb: String
  eyebrow: String
  headline: String
  imageUrl: URL
  linkUrl: URL
  published: Boolean!
  publisher: String
  status: ExtraStatus!
  type: LearnModuleTypes!

  # Not a URL: some text, suitable for a link's text.
  visibleUrl: String
  year: String
}

# Types a LearnModule can have
enum LearnModuleTypes {
  # an old partnership
  BBC_RADIO4
  BOOK
  COMPANION_FILM

  # an external website. http? https? who knows?
  EXTERNAL_WEBSITE
  FROM_THE_BLOG
  IMAGE_GALLERY

  # what's happened since then?
  SINCE_THE_TALK
}

# Types of things that can be liked (stored in Identity)
enum LikableItemType {
  PLAYLIST
  VIDEO
}

# An item (a video or playlist) a user has liked.
type LikedItem {
  id: ID!
  itemId: ID!
  itemType: LikableItemType!
}

# Autogenerated return type of LikeItem
type LikeItemPayload {
  errors: [String!]
  item: LikedItem
}

type MembershipEvent {
  # UTC beginning time of the membership event
  beginAt: ISO8601DateTime!

  # UTC ending time of the membership event
  endAt: ISO8601DateTime!

  # ID of the membership event
  id: ID!

  # User registered for the membership event?
  isRegistered: Boolean!

  # Membership candidate type sold out?
  isSoldOut: Boolean!

  # Sessions of the membership event
  membershipEventSessions: [MembershipEventSession!]!

  # IANA timezone name of the membership event
  timezoneName: String!

  # Title of the membership event
  title: String!
}

type MembershipEventSession {
  # UTC beginning time of the membership event session
  beginAt: ISO8601DateTime!

  # Description of the membership event session
  description: String!

  # UTC ending time of the membership event session
  endAt: ISO8601DateTime!

  # ID of the membership event
  eventId: ID!

  # ID of the membership event session
  id: ID!

  # Speakers of the membership event session
  membershipEventSpeakers: [MembershipEventSpeaker!]!

  # Session format name, sometimes thought of as membership event type
  sessionFormatName: String!

  # Label of URL to join the membership event session
  sessionSignupLabel: String!

  # URL to join the membership event session
  sessionSignupUrl: String!

  # Title of the membership event session
  title: String!
}

type MembershipEventSpeaker {
  # Photo URL of the membership event speaker
  avatar: String

  # Short description of the membership event speaker, aka nugget
  description: String!

  # First name of the membership event speaker
  firstName: String!

  # ID of the membership event speaker
  id: ID!

  # Last name of the membership event speaker
  lastName: String!

  # First name of the membership event speaker
  middleName: String!

  # Slug of the membership event speaker
  slug: String!

  # Type of this speaker talk, either "Main Speaker" or "Interviewer"
  speakerTalkTypeName: String!

  # What other people say about the membership event speaker
  whatOthersSay: String

  # Longer description of the membership event speaker
  whoTheyAre: String

  # Why people should listen to the membership event speaker
  whyListen: String
}

type MembershipSubscription {
  expiresAt: ISO8601DateTime!
  id: ID!
  isCancelled: Boolean!
  paymentPlatformId: ID!
  skuId: ID
  stripePrice: String
  transactionId: String!
}

type MotivatorConnection {
  edges: [MotivatorEdge!]!
}

type MotivatorEdge {
  cursor: ID!
  node: ExploreMotivator!
}

type Mutation {
  addPaymentMethod(
    makeDefault: Boolean
    paymentMethodId: String!
  ): AddPaymentMethodPayload
  cancelStripeSupporterSubscription(
    additionalComments: String
    email: String!
    name: String!
    paymentAmount: String!
    paymentInterval: String!
    reason: String!
    subscriptionId: ID!
  ): CancelStripeSupporterSubscriptionPayload
  createPaymentIntentClientSecret(
    priceAmountUsdCents: Int!
  ): CreatePaymentIntentClientSecretPayload
  createStripeSupporterSubscription(
    cardTokenId: ID!
    email: String
    priceAmountUsdCents: Int!
    recaptchaToken: String!
    sku: ID!
    subscriptionMetadata: SubscriptionMetadata
  ): CreateStripeSupporterSubscriptionPayload
  purchaseGiftMembership(
    cardTokenId: ID!
    dateToSend: ISO8601DateTime!
    giftMembershipMetadata: SubscriptionMetadata
    personalMessage: String
    recaptchaToken: String!
    recipientEmail: String!
    recipientFirstName: String!
    recipientLastName: String!
    senderEmail: String!
    senderFirstName: String!
    senderLastName: String!
  ): PurchaseGiftMembershipPayload
  redeemGiftMembership(token: String!): RedeemGiftMembershipPayload
  redeemStripeSubscriptionToken(
    token: String!
  ): RedeemStripeSubscriptionTokenPayload
  removePaymentMethod(paymentMethodId: String!): RemovePaymentMethodPayload
  renewExpiredStripeSubscriptionToken(
    token: String!
  ): RenewExpiredStripeSubscriptionTokenPayload
  toggleFavorite(
    favoriteable: FavoriteInput!
    shouldFavorite: Boolean
  ): ToggleFavoriteMutationPayload
  toggleFollow(
    shouldFollow: Boolean
    subject: FollowSubjectInput!
  ): ToggleFollowMutationPayload
  toggleSavedPlaylist(
    playlistId: ID!
    shouldSaveForLater: Boolean
  ): ToggleSavedPlaylistMutationPayload
  updateDefaultPaymentMethod(
    paymentMethodId: String!
  ): UpdateDefaultPaymentMethodPayload
  likeItem(id: ID!, itemType: LikableItemType!): LikeItemPayload
  removeYourListItem(id: ID!): RemoveYourListItemPayload
  saveVideoToYourList(id: ID!, secondsPlayed: Int!): SaveVideoToYourListPayload
  unlikeItem(id: ID!): UnlikeItemPayload

  # Cancel an attendee's registration to a membership event
  cancelMembershipEventRegistration(
    # the event id of the registration to be cancelled
    id: ID!
  ): CancelMembershipEventRegistrationPayload

  # Create an attendee's registration to a membership event
  registerMembershipEvent(
    # the event id of the registration to be created
    id: ID!
  ): RegisterMembershipEventPayload
  exploreToggleEmail(status: EmailStatusEnum): EmailStatus!
  interestRecord(input: UserInterestInput!): InterestRecordResponse!
  endorsementSubmit(input: EndorsementSubmitInput!): EndorsementSubmitResponse!
  endorsementSetUpvoted(id: ID!, upvoted: Boolean): EndorsementUpvoteResponse!
  id: Int
}

type NativeDownloads {
  # A hi-res download
  high: URL

  # A low-res download
  low: URL

  # A medium-res download
  medium: URL
}

# Results sort order, when not provided, order defaults to `playlist#updated_at`
input OrderingOptions {
  # Order by `display_order`
  displayOrder: OrderOptions

  # Order by featured slot, meant to be used with the `in_featured_slot` filter.
  featuredSlot: OrderOptions

  # Order by `updated_at`
  updatedAt: OrderOptions
}

# Results order sorting options
enum OrderOptions {
  # Sort results in ascending order
  ASC

  # Sort results in descending order
  DESC
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, the cursor to continue.
  endCursor: String

  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String
}

type Pancake {
  id: ID!
  lastPublishedVersion: String
  playlists(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): PlaylistConnection!
}

# The connection type for Pancake.
type PancakeConnection {
  # A list of edges.
  edges: [PancakeEdge]

  # A list of nodes.
  nodes: [Pancake]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type PancakeEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Pancake
}

type Paragraph {
  cues: [Cue!]!
}

type PaymentMethod {
  card: Card
  id: String!
}

type Permissions {
  explore: [String!]
}

type PhotoSize {
  # Width / height.
  aspectRatio: AspectRatio

  # Either a short string of the ratio, or a descriptive name for it like Facebook.
  aspectRatioName: String

  # The height of the photo in pixels.
  height: Int
  url: String

  # The width of the photo in pixels.
  width: Int
}

type Platform {
  id: ID!
  pancakes(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): PancakeConnection
  ribbons(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): RibbonConnection
  spotlightUnits(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): SpotlightUnitConnection
}

# A string of JSON, that can be parsed, and passed to the TED video player.
scalar PlayerData

type Playlist {
  # Who put this playlist together? It's usually 'TED.'
  author: String!

  # Plain-text, not HTML.
  description: String

  # A unix timestamp integer. Nicely sortable.
  displayOrder: Int!

  # Duration of the whole playlist, in seconds.
  duration: Int!

  # Playlists with this value should appear on the homepage, sorted by this.
  featuredSlotNumber: Int
  id: ID!

  # A playlist can have >1 photoset in talkstar. This is its primary one. Pick your aspect ratio.
  primaryImageSet: [PhotoSize!]!

  # Whether the talk has been published to the world yet.
  published: Boolean!
  publishedAt: ISO8601DateTime!

  # A label to use for the playlist season in the front-end. For example "2019".
  seasonLabel: String

  # If this playlist is part of a season, this tells you which season it is.
  seasonNumber: String

  # The series that this playlist belongs to
  series: Series
  slug: String!

  # Use this description when sharing the playlist to social media.
  socialDescription: String

  # Use this title when sharing the playlist to social media.
  socialTitle: String
  title: String!
  videos(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int
    language: String

    # Returns the last _n_ elements from the list.
    last: Int
  ): VideoConnection!
}

# The connection type for Playlist.
type PlaylistConnection {
  # A list of edges.
  edges: [PlaylistEdge]

  # A list of nodes.
  nodes: [Playlist]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type PlaylistEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Playlist
}

# Autogenerated return type of PurchaseGiftMembership
type PurchaseGiftMembershipPayload {
  giftMembershipToken: String
  success: Boolean
}

type Query {
  # A simple query that relies on nothing. Suitable for specs and health-checks.
  identityPing: String!

  # Find a user
  viewer: User
  doYouLikeItem(itemId: ID!, itemType: LikableItemType!): LikedItem
  ping: String!

  # A simple query that relies on nothing. Suitable for specs and health-checks.
  roadrunnerPing: String!
  speaker(id: ID!): Speaker
  translation(language: String!, videoId: ID!): Translation
  video(
    # Which channel to use.
    channelId: Int = 2
    id: ID
    language: String = "en"
    slug: String
  ): Video
  yourListItem(itemId: ID!, itemType: YourListItemType!): YourListItem

  # membership events
  membershipEvents(
    # intended for public and non-membership viewers when true, the events have public sessions and return public descriptions
    public: Boolean
  ): [MembershipEvent!]
  exploreStatus: ExploreStatus!
  exploreMotivators: [ExploreMotivator!]!
  endorsement(id: ID!): Endorsement
  acmeLanguages(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): AcmeLanguageConnection
  acmeSpeaker(id: ID!): AcmeSpeaker
  acmeSpeakers(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): AcmeSpeakerConnection
  platform(id: ID!): Platform
  playlist(id: ID, slug: String): Playlist
  playlists(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Filter playlists by curator.
    curator: CuratorOptions

    # When `true` limit results to playlists in the "featured" channel.
    featured: Boolean

    # Returns the first _n_ elements from the list.
    first: Int

    # When `true` limit results to playlists which have a `featured_slot_number`.
    inFeaturedSlot: Boolean

    # Returns the last _n_ elements from the list.
    last: Int

    # Results ordering options.
    order: OrderingOptions

    # When `true` limit results to playlists "published" in playlist channel.When
    # `false` both "published" and "unpublished" playlists will be returned.
    published: Boolean

    # An Array of topics which playlists should belong to, this is an OR not an AND.
    topics: [String!]
  ): PlaylistConnection
  series(slug: String!): Series
  topic(slug: String!): Topic
  topicList(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): TopicListItemConnection
  videos(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Which channel to use.
    channel: ChannelOptions = FEATURED

    # Returns the first _n_ elements from the list.
    first: Int
    id: [Int!]
    isPublished: [Boolean!] = [true]
    language: String = "x-orig"

    # Returns the last _n_ elements from the list.
    last: Int
    slug: [String!]
  ): VideoConnection
}

# What kind of recommendation item is it?
enum RecItemLabel {
  EXPLORE
  LISTEN
  READ_ARTICLE
  READ_BOOK
  WATCH
}

# A 'recommendation'
type Recommendation {
  blurb: String!
  recLists: [RecommendationList!]!
}

# A recommendation item
type RecommendationItem {
  blurb: String!
  eyebrow: String
  headline: String!
  isPdf: Boolean!
  label: RecItemLabel!
  linkUrl: String!
  note: String
}

# A recommendation list...a list of recommendation items
type RecommendationList {
  description: String!
  recItems: [RecommendationItem!]!
  title: String!
}

# Autogenerated return type of RedeemGiftMembership
type RedeemGiftMembershipPayload {
  status: String!
}

# Autogenerated return type of RedeemStripeSubscriptionToken
type RedeemStripeSubscriptionTokenPayload {
  status: RedeemSubscriptionTokenStatus!
}

# Types of things that can be happen when you redeem a SubscriptionToken
enum RedeemSubscriptionTokenStatus {
  # All clear: the token was just successfully redeemed.
  SUCCESS

  # This token was already redeemed
  TOKEN_ALREADY_REDEEMED

  # This token has expired; try renewing it.
  TOKEN_EXPIRED
}

# Autogenerated return type of RegisterMembershipEvent
type RegisterMembershipEventPayload {
  membershipEvent: MembershipEvent
}

# Autogenerated return type of RemovePaymentMethod
type RemovePaymentMethodPayload {
  status: String!
}

# Autogenerated return type of RemoveYourListItem
type RemoveYourListItemPayload {
  errors: [String!]!
  item: YourListItem
}

# Autogenerated return type of RenewExpiredStripeSubscriptionToken
type RenewExpiredStripeSubscriptionTokenPayload {
  status: RenewExpiredSubscriptionTokenStatus!
}

# Types of things that can be happen when you renew an expired SubscriptionToken
enum RenewExpiredSubscriptionTokenStatus {
  # All clear: the token was successfully renewed
  SUCCESS

  # This token was already redeemed
  TOKEN_ALREADY_REDEEMED

  # This token hasn't expired yet
  TOKEN_NOT_EXPIRED
}

type Ribbon {
  id: ID!
  lastPublishedVersion: String
  live: Boolean
  name: String
  order: Int
  slots(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): SlotConnection
  sponsorLogo: String
  sponsorName: String
  sponsored: Boolean
}

# The connection type for Ribbon.
type RibbonConnection {
  # A list of edges.
  edges: [RibbonEdge]

  # A list of nodes.
  nodes: [Ribbon]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type RibbonEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Ribbon
}

# Autogenerated return type of SaveVideoToYourList
type SaveVideoToYourListPayload {
  errors: [String!]!
  item: YourListItem
}

type Series {
  id: ID!
  name: String!
  playlists(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): PlaylistConnection
  publishedPlaylistCount: Int!
  slug: String!
}

type Slot {
  duration: Int
  id: ID!
  image: String
  link: String
  order: Int
  remote: Boolean
  sponsored: Boolean
  title: String
  video(channelId: String, language: String): Video
}

# The connection type for Slot.
type SlotConnection {
  # A list of edges.
  edges: [SlotEdge]

  # A list of nodes.
  nodes: [Slot]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type SlotEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Slot
}

type Speaker {
  avatar: URL!

  # Another short bit of HTML. ~500 characters, often blank. If queried through a
  # non-curator-approved TEDx talk, it'll be null.
  description: String!

  # Part of their name. But think about using Video.presenterDisplayName first.
  firstName: String
  id: ID!

  # Part of their name. But think about using Video.presenterDisplayName first.
  lastName: String

  # Part of their name. But think about using Video.presenterDisplayName first.
  middleName: String

  # An unpublished speaker should not link to their speaker page...it'll 404.
  published: Boolean!
  slug: String!
  title: String
  users: [User!]!

  # Usually under 1,000 characters, sometimes contains HTML.
  whatOthersSay: String!

  # A usually short field with a bit of HTML. If queried through a non-curator-approved TEDx talk, it'll be null.
  whoTheyAre: String!

  # Up to 5,000 characters of HTML.
  whyListen: String!
}

type SpotlightUnit {
  content: String
  id: ID!
  imageUrl: String
  position: Int
  published: Boolean
  title: String
  url: String
}

# The connection type for SpotlightUnit.
type SpotlightUnitConnection {
  # A list of edges.
  edges: [SpotlightUnitEdge]

  # A list of nodes.
  nodes: [SpotlightUnit]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type SpotlightUnitEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: SpotlightUnit
}

input SubjectFilter {
  id: ID!
  type: String!
}

# A JSON object to be passed to Stripe on purchase
scalar SubscriptionMetadata

type SubtitledDownload {
  # A hi-res download
  high: URL

  # The code of the language the subtitles are in
  internalLanguageCode: String!

  # The name of the language the subtitles are in
  languageName: String!

  # A low-res download
  low: URL
}

# A take-action module from talkstar
type TakeActionModule {
  blurb: String
  endAt: ISO8601DateTime
  eyebrow: String
  linkUrl: URL
  published: Boolean!
  startAt: ISO8601DateTime
  status: ExtraStatus!
  verb: String!
  visibleUrl: String
}

# data from Talk Extras, with just-enough modelling
type TalkExtras {
  footnotes: [Footnote!]!
  learnModules: [LearnModule!]!
  recommendations: [Recommendation!]!
  takeAction: [TakeActionModule!]!
}

type TalkGrade {
  id: ID!
  name: String!
}

# Autogenerated return type of ToggleFavoriteMutation
type ToggleFavoriteMutationPayload {
  updatedFavorites: [Favorite!]
  viewer: User
}

# Autogenerated return type of ToggleFollowMutation
type ToggleFollowMutationPayload {
  updatedFollows: [Follow!]
  viewer: User
}

# Autogenerated return type of ToggleSavedPlaylistMutation
type ToggleSavedPlaylistMutationPayload {
  updatedPlaylists: [Playlist!]
  viewer: User
}

type Topic {
  id: ID!
  name: String
  playlists(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int

    # Results ordering options.
    order: OrderingOptions
  ): PlaylistConnection

  # A short human-readable identifier for this Topic. Suitable for building URLs.
  slug: String
  videos(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int
    languageCode: String

    # Returns the last _n_ elements from the list.
    last: Int
  ): VideoConnection
}

# The connection type for Topic.
type TopicConnection {
  # A list of edges.
  edges: [TopicEdge]

  # A list of nodes.
  nodes: [Topic]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type TopicEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Topic
}

type TopicListItem {
  id: ID!
  name: String

  # A short human-readable identifier for this TopicListItem. Suitable for building URLs.
  slug: String
}

# The connection type for TopicListItem.
type TopicListItemConnection {
  # A list of edges.
  edges: [TopicListItemEdge]

  # A list of nodes.
  nodes: [TopicListItem]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type TopicListItemEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: TopicListItem
}

type Translation {
  id: ID!
  language: Language
  paragraphs: [Paragraph!]!
  reviewer: User
  translator: User
}

type TypeOfVideo {
  id: ID!
  name: String!
}

# Autogenerated return type of UnlikeItem
type UnlikeItemPayload {
  errors: [String!]
  item: LikedItem
}

# Autogenerated return type of UpdateDefaultPaymentMethod
type UpdateDefaultPaymentMethodPayload {
  status: String!
}

# A valid URL, transported as a string
scalar URL

type User {
  avatar: UserAvatar!
  byline: String
  defaultPaymentMethod: PaymentMethod
  favorites(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String
    filter: FavoritesFilter

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): FavoriteConnection
  follows(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String
    filter: FollowsFilter

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): FollowConnection

  # Do not send alerts, notifications, emails, etc to this user if false
  hasMemberNotificationsEnabled: Boolean!
  hasMembersMightyNetworkAccess: Boolean!
  id: ID!

  # True if the users current membership was gifted
  isGiftedMember: Boolean!

  # True if a user is an active TED Member.
  isMember: Boolean!

  # True if a user is a paying supporter
  isSupporter: Boolean!

  # membership subscription if user is a paying supporter
  membershipSubscription: MembershipSubscription
  name: UserName!
  paymentMethods: [PaymentMethod!]
  primaryEmailAddress: String
  profileUrl: String! @deprecated(reason: "Use profilePath instead")
  savedPlaylists(ids: [ID!]): [Playlist!]
  fullName: String @deprecated(reason: "Moving responsibility to identity")
  profilePath: URL
  uri: URL @deprecated(reason: "Use profilePath instead")
  permissions: Permissions
  endorsements(videoId: ID): EndorsementsConnection!
}

type UserAvatar {
  generatedUrl(type: GeneratedAvatar): String!
  url: String
}

type UserInterest {
  id: ID!
  subjectType: String
  subjectId: Int
  scope: String
}

input UserInterestInput {
  subjectType: String
  subjectId: Int
  scope: String
}

type UserName {
  first: String
  full: String
  last: String
}

type Video {
  acmePlayerData(
    # A string of JSON, that can be parsed, and passed to the TED video player.
    playlistReferrerSlug: String
    preview: Boolean
  ): AcmePlayerData!

  # The language the speaker is speaking in.
  audioInternalLanguageCode: String

  # We're not 100% sure this should go here? It could be calculated from the slug. Otoh, it's nice to centralize that logic.
  canonicalUrl: String!

  # Has this video been reviewed and approved by TED editorial staff?
  curatorApproved: Boolean

  # Paragraph-length description of the video's content. May be blank in some cases.
  description: String

  # Perform a descending-order sort on this value to achieve the ordering
  # intended by TED editors. (Collections will be ordered by this value by
  # default.) Actual value is an arbitrary numeric value. Note that this value can vary per channel.
  displayOrder: ISO8601DateTime

  # Duration of the video, in seconds.
  duration: Int!

  # A fallback URL if the hls URL does not work.
  fallbackUrl: String!
  id: ID!

  # The language the title, description, speaker name, and transcripts are in.
  # It's probably what was requested, but not guaranteed...sometimes we fall back
  # to English, or the language the talk was given in.
  internalLanguageCode: String

  # Is the video currently published in the selected channel?
  # In most cases, non-published videos should not be displayed to clients.
  # true or false
  # Note that this value can vary per channel.
  # 'any' can also be passed to return records of any value for this field
  isPublished: Boolean!

  # Should subtitles be automatically displayed when video playback starts? This
  # value is advice from the TED editorial staff, intended for a primarily
  # English-speaking audience. It typically identifies non-English TED Talks or
  # videos where the speaker's speech is difficult to understand.
  isSubtitleRequired: Boolean
  language: String

  # For a Salon or Institute talk, this will be the partner name (extracted from
  # the video's context field. For anything else (including a custom-content
  # video), it'll be null.
  partnerName: String

  # A single string describing the speaker(s) in a video. Intended for display
  # purposes only. Use the `speakers` relationship for more detailed information.
  presenterDisplayName: String

  # A video can have >1 photoset in talkstar. This is its primary one.
  primaryImageSet: [PhotoSize!]

  # Time at which the video was most recently published. Most
  # videos are only published once, but in the rare cases where a video is
  # unpublished and then later re-published, this field will contain the
  # most recent publication date. Note that this value can vary per channel.
  publishedAt: ISO8601DateTime

  # The subtitles that have been published for the talk.
  publishedSubtitleLanguages(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): AcmeLanguageConnection

  # Date that a video was created. Note this is the date of content creation, not publication. Can be null.
  recordedOn: ISO8601Date

  # A short human-readable identifier for this video. Suitable for building URLs.
  slug: String

  # Use this description when sharing the video to social media.
  socialDescription: String

  # Use this title when sharing the video to social media.
  socialTitle: String

  # Speakers who are associated with this video.
  speakers(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): AcmeSpeakerConnection

  # The video title. No speaker name prepended.
  title: String!
  topics(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    limit: Int
  ): TopicConnection

  # Unique identifier for the this master's current media stream. This value
  # should be delivered & cached alongside the hls_url and metadata_url. It
  # identifies unique values of those fields.
  versionIdentifier: String!

  # Often, the event the talk was given at. It's 'TED-Ed' for TED-Ed videos. We
  # pull partner info out of these for Institute and Salon talks. Ultimately, this
  # is controlled by editorial.
  videoContext: String!

  # Zero or more Consus-encoded video downloads for this talk.
  videoDownloads(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): VideoDownloadConnection!
  videometricsVideoId: ID
  audioDownload: URL

  # For custom-content videos (yet another variety of partnership), we use this
  # data to override the 'Speaker' block, to make it seem like the partner is the
  # speaker. This is a hack until we get ~better support for this in Talkstar.
  customContentDetails: CustomContentDetails

  # These only apply to certain videos. It'll be there if it needs to be.
  eventBadge: EventBadge

  # Was this video published to TalkStar's 'featured' channel? ...which also syncs videos to Symfony?
  featured: Boolean!
  hasTranslations: Boolean!
  nativeDownloads: NativeDownloads

  # A string of JSON, that can be parsed, and passed to the TED video player. We may turn this into a real object? Not sure.
  playerData: PlayerData!

  # Any curated watch-next videos from talkstar, back-filled from Rae.
  relatedVideos(count: Int, language: String): [Video!]!
  subtitledDownloads: [SubtitledDownload!]!

  # Data from talk-extras, with just-enough modelling
  talkExtras: TalkExtras!
  type: TypeOfVideo!

  # The count of times the video has been watched. We don't display these if
  # they're <10k, but that's up to the client (currently).
  viewedCount: Int!
  endorsements: EndorsementsConnection!
  motivators: MotivatorConnection!
  recommendationsLastWeek: Int!
  averageRecommendationsLastFourWeeks: Int!
}

# The connection type for Video.
type VideoConnection {
  # A list of edges.
  edges: [VideoEdge]

  # A list of nodes.
  nodes: [Video]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

type VideoDownload {
  # Video height in pixels
  height: Int!

  # Location of video download
  url: String!
}

# The connection type for VideoDownload.
type VideoDownloadConnection {
  # A list of edges.
  edges: [VideoDownloadEdge]

  # A list of nodes.
  nodes: [VideoDownload]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type VideoDownloadEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: VideoDownload
}

# An edge in a connection.
type VideoEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Video
}

# An item on a list of a user's saved videos & playlists, to watch later.
type YourListItem {
  id: ID!
  itemId: ID!
  itemType: YourListItemType!
  secondsPlayed: Int!
}

# Types of things that can be saved to Your-List
enum YourListItemType {
  PLAYLIST
  VIDEO
}
